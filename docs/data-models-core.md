# Data Models – Core Integration Surfaces

This backend relies on external platforms (Microsoft Graph / SharePoint Online, Azure Table Storage, UiPath Orchestrator). No relational schema is bundled, but several structured stores are managed at runtime.

## Azure Table Storage

| Table | Purpose | Partition / Row Keys | Shape |
| --- | --- | --- | --- |
| `SharePointItemStates` | Baseline snapshot for change detection (`initialize-item-states`). Ensures new notifications can diff against previous versions. | `partitionKey` – normalized resource path (`sites/.../lists/...` → underscores); `rowKey` – `item_{itemId}` | `{ resource, itemId, lastModified, previousState (JSON), timestamp }` |
| `WebhookMetrics` | Telemetry captured by `shared/metrics-collector` for notifications, forwarding attempts, and webhook operations. | `partitionKey` categories (`notifications`, `forwarding`, `webhook-operations`); `rowKey` – timestamp/random suffix. | Each entity includes success flag, latency, error metadata, plus contextual fields (`subscriptionId`, `targetUrl`, `operation`). |
| `WebhookHealth` | Rolling health-check timeline generated by `metrics-collector.recordHealthCheck`. | `partitionKey = 'health'`; `rowKey` = ISO timestamp. | `{ status, checksJson, alertsJson, alertCount, criticalAlerts }` enabling availability reporting. |

### Table Creation & Resiliency
- `initialize-item-states` ensures `SharePointItemStates` exists (creates table if missing).
- Metrics collector lazily creates entities; failures are logged but non-blocking.

## SharePoint Lists (via Graph API)

### Webhook Management List
Populated by `webhook-sync.js`, persisted through Microsoft Graph. Key fields:

- `Title` – formatted as `<ResourceType> - <ListName>`
- `SubscriptionId`, `ChangeType`, `NotificationUrl`, `ExpirationDateTime`
- `Status` (Active/Deleted), `AutoRenew`, `NotificationCount`
- `SiteUrl`, `ListId`, `ListName`, `ResourceType`
- Proxy metadata: `ClientState`, `ForwardingUrl`, `IsProxy`, `LastForwardedDateTime`

Any subscription missing from Graph during reconciliation is marked `Status = 'Deleted'`.

### Test / Domain Lists
`config.sharepoint.listMappings` references additional lists (e.g., Costco inline routing). Content is accessed dynamically when webhook notifications resolve list IDs; schema is not stored locally but normalized at runtime by `shared/sharepoint-document-handler.js`.

## UiPath Queue Payloads

- Queues are sent via `shared/uipath-queue-client.js` (REST calls to `/odata/Queues/UiPathODataSvc.AddQueueItem`).
- Minimum payload: `{ Name, SpecificContent, Priority?, Reference? }`.
- `SpecificContent` is flattened and SharePoint field names are encoded to UiPath-safe keys (e.g., spaces → `_x0020_`).
- Custom processors (e.g., Costco template) enrich content with additional derived fields before dispatch.

## Derived Documents & Reports

- Enriched notification objects include normalized SharePoint fields, change metadata, and UiPath routing context. Transformation logic lives in `shared/sharepoint-document-handler` and `templates/costco-inline-routing.js`.
- Health-check responses combine live Graph subscription data, storage connectivity, and metrics rollups into a JSON document returned by `health-check`.

## Observations

- No relational schema or migrations are shipped; the backend leans on Graph (SharePoint lists) plus Azure Table Storage.
- Telemetry tables grow over time; consider lifecycle policies or periodic archival.
- SharePoint field name mappings are centralized (`SHAREPOINT_FIELD_MAPPINGS` in `shared/constants.js`) to keep UiPath payloads stable even if list columns rename.

Total model groups documented: **3** (Azure Table Storage, SharePoint lists, UiPath queues).
